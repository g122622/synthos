# 需求背景： 现在已有的这个 orchestrator 到底在“编排”什么？

## 1.1 固定写死的 5 步串行 Pipeline

`orchestrator` 定义了一个 `RunPipeline` 任务，然后在里面按顺序触发 6 个任务，并且每一步都“等上一部完成才继续”。

```13:160:/synthos/applications/orchestrator/src/index.ts
/**
 * Pipeline 执行顺序（严格串行）:
 * 1. ProvideData - 获取原始数据
 * 2. Preprocess - 预处理数据
 * 3. AISummarize - AI 摘要生成
 * 4. GenerateEmbedding - 生成向量嵌入
 * 5. InterestScore - 计算兴趣度评分
 * 6. LLMInterestEvaluationAndNotification - 基于 LLM 的兴趣评分
 */
// ...
const provideDataSuccess = await scheduleAndWaitForJob(TaskHandlerTypes.ProvideData, { /*...*/ }, POLL_INTERVAL, TASK_TIMEOUT);
// ...
const preprocessSuccess = await scheduleAndWaitForJob(TaskHandlerTypes.Preprocess, { /*...*/ }, POLL_INTERVAL, TASK_TIMEOUT);
// ...
```

## 1.2 “等待完成”的机制：不是 DAG 引擎，而是轮询 Mongo(Agenda jobs)

它用 `scheduleAndWaitForJob()`：先 `agendaInstance.now()` 立刻塞一个 job，然后轮询这个 jobId 的状态，直到 `lastFinishedAt` 或 `failedAt`。

```178:192:/synthos/common/scheduler/jobUtils.ts
export async function scheduleAndWaitForJob<T extends TaskHandlerTypes>(
    taskName: T,
    data: TaskParamsMap[T],
    pollIntervalMs: number,
    timeoutMs: number
): Promise<boolean> {
    LOGGER.info(`调度任务 [${taskName}]`);
    const job = await agendaInstance.now(taskName, data);
    return waitForJobCompletionByIdV3(job.attrs._id.toString(), pollIntervalMs, timeoutMs);
}
```

## 1.3 任务处理器分布在其它 apps 进程

- `ProvideData` 在 `applications/data-provider/src/index.ts` 里 `agendaInstance.define(...)`
- `Preprocess` 在 `applications/preprocessing/src/index.ts`
- `AISummarize/GenerateEmbedding/InterestScore/GenerateReport/...` 在 `applications/ai-model/src/tasks/*`

也就是说：**orchestrator 只是发号施令**；各任务由其它 Node 进程作为 worker 执行（共享同一个 MongoDB 的 `synthos_jobs` 集合）。

## 1.4 报告调度是独立子调度器

`orchestrator` 里还有 `setupReportScheduler()`：按 cron 配置定时 `agendaInstance.now(GenerateReport, ...)`。

```60:203:/synthos/applications/orchestrator/src/schedulers/reportScheduler.ts
await agendaInstance.every(cronExpression, `HalfDailyReport_${timeStr}`, {}, { skipImmediate: true });
// ...
agendaInstance.define(`HalfDailyReport_${timeStr}`, async () => {
  await agendaInstance.now(TaskHandlerTypes.GenerateReport, { reportType: "half-daily", timeStart, timeEnd });
});
```

## 1.5 现状总结

- **orchestrator** 是一个"脚本式"串行控制器，在 [index.ts]() 中硬编码了 6 步 Pipeline（ProvideData → Preprocess → AISummarize → GenerateEmbedding → InterestScore → LLMInterestEvaluation），用 [scheduleAndWaitForJob]() 轮询 MongoDB/Agenda 来等待各步骤完成
- 各步骤的实际执行分布在 data-provider、preprocessing、ai-model 三个独立进程中，通过共享 MongoDB 的 Agenda jobs 集合来协调
- 报告调度 (`reportScheduler`) 是独立于主 Pipeline 的 cron 任务
- 现有 tRPC 通信链路：[ai-model]() 暴露 RPC 服务（端口由 [config.ai.rpc.port]() 配置）→ `webui-backend` 通过 WebSocket 作为 tRPC 客户端连接 → 前端通过 `webui-backend` 的 `/trpc` WebSocket 端点进行 subscription
- 前端使用 React + HeroUI + Tailwind，路由在 App.tsx中定义
- [Logger]当前是写文件+控制台，没有可编程的日志 sink 机制

# 需求概述

## 工作流和流程编排引擎

现在orchestrator是“固定脚本串行调用”。我们要的“拖拽编排”本质需要两块能力：

1) **可视化建模**：拖拽节点、连线、配置节点参数（这是 UI / 模型）
2) **运行时执行器**：把图（DAG/流程）解释成一次次 job 调度，并处理：
   - 节点依赖（前置完成才运行）
   - 分支/并行/汇聚
   - 重试、超时、失败策略、跳过策略
   - 运行历史、可观测性
   - 支持**分支/并行/汇聚/条件判断**
   - 支持看到当前执行状态，运行到哪一步了

现有代码可能已经包含部分上述逻辑（如检查网络连接、重试等），但是很分散且不好治理。

我们现在已有的只有：Agenda（定时/队列） + 一个“脚本式顺序控制”。

流程里节点类型需要覆盖现有 `TaskHandlerTypes`（ProvideData/Preprocess/...），也希望未来能“自定义脚本节点/HTTP 节点/循环”等。

关联流程执行 ID：每次 Pipeline 运行有唯一标识，日志带上这个 ID

因为上述需求比较复杂，因此我想引入自研的的工作流和流程编排引擎。

我们希望流程定义存放在—继续沿用配置体系（`synthos_config.json`），好处是简单、可备份。保存时需要像applications\webui-frontend\src\pages\config-panel\config.tsx那样进行diff，待用户确认之后再保存。流程定义被修改后，正在运行的流程执行时深拷贝流程定义快照，运行期间不受修改影响

条件分支要支持简单的 key-value 匹配（如：previousNodeResult.success === true），内置几种预定义条件。

上游节点的输出如何传给下游节点——全局执行上下文 ExecutionContext，所有节点共享一个 Map<nodeId, output>，下游节点可读取上游输出。但需注意别读到过时的老数据了

一次流程执行的中间状态（各节点状态、输出、错误信息）需要持久化，以支持断点续跑

DAG 引擎尽量与实际业务逻辑解耦，就像游戏引擎、js引擎那样与实际业务解耦，不关注具体的任务、业务等；需要充分的单元测试覆盖

新引擎仍然调用 agendaInstance.now(taskName, params)，完全复用现有 task handler

## 流程定义契约草案

下面只是不完整的草案，仅供参考，你可以对其增、删、修改！

```ts
interface WorkflowDefinition {
  id: string;
  name: string;
  description: string;
  nodes: WorkflowNode[];
  edges: WorkflowEdge[];
  // React Flow 画布 viewport 状态（用于保存/恢复）
  viewport?: { x: number; y: number; zoom: number };
}

interface WorkflowNode {
  id: string;
  type: WorkflowNodeType; // "task" | "condition" | "parallel" | "script" | "http" | "start" | "end"
  position: { x: number; y: number };  // React Flow 位置
  data: {
    label: string;
    taskType?: TaskHandlerTypes; // 仅 type="task" 时有效
    params?: Record<string, any>; // 节点参数
    retryCount?: number;
    timeoutMs?: number;
    skipOnFailure?: boolean;
    conditionExpression?: string; // 仅 type="condition" 时
    scriptCode?: string; // 仅 type="script" 时
    httpConfig?: { url: string; method: string; headers?: Record<string,string>; body?: string; }; // 仅 type="http" 时
  };
}

interface WorkflowEdge {
  id: string;
  source: string;     // 源节点 id
  target: string;     // 目标节点 id
  sourceHandle?: string; // 用于条件分支的 handle
  label?: string;      // 如 "true" / "false"
}
```

## 日志

需要把各个任务执行期间的logger输出全部展示到前端页面（项目已有日志轮询显示功能，可以利用applications\webui-frontend\src\pages\system-monitor\logs.tsx组件及其对应后端api（组件稍作修改之后提升到src/components下作为公共组件）（后端api也要修改以便选取不同task生成的日志））

## 前端

我们希望“编排 UI”集成到现有 `webui-frontend` 里（作为src/pages下一个新页面 /workflow ），打算在前端使用 <https://reactflow.dev/examples/overview> 也就是 @xyflow/react（React Flow v12） 这个库。

状态管理使用 Zustand（React Flow 官方推荐，且轻量）（

## RPC

目前 orchestrator 不暴露任何端口。要支持前端实时查看执行状态/日志和手动触发流程，需要通信链路：orchestrator 新增 tRPC 服务端（类似 ai-model 的模式），webui-backend 作为 tRPC 客户端连接并转发给前端。

## 旧代码清理

改造完成后，现有的硬编码 Pipeline 必须完全删除，替换为引擎从存储中读取默认 WorkflowDefinition 并执行

## 其他

reportScheduler 也要纳入流程编排（纳入离散的定时任务体系）

改造完成后需要更新：

根目录 README.md（功能列表、TODO 愿望单）
README.md（新增流程引擎说明）
API文档.md（新增 orchestrator RPC 接口）
新增 docs/工作流编排使用指南.md（用户手册）
新增 docs/工作流编排技术报告.md（技术向解析）

# 需求排期

由于上述需求复杂，请你先充分探索这个项目（并联网阅读 https://reactflow.dev 文档），然后进行树状需求分解 + 进行需求排期（因为一次肯定做不完这些东西！），输出一份详细、完善、专业的排期文档。
