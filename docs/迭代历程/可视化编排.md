# 需求背景： 现在已有的这个 orchestrator 到底在“编排”什么？

### 1.1 固定写死的 5 步串行 Pipeline

`orchestrator` 定义了一个 `RunPipeline` 任务，然后在里面按顺序触发 5 个任务，并且每一步都“等上一部完成才继续”。

```13:160:/synthos/applications/orchestrator/src/index.ts
/**
 * Pipeline 执行顺序（严格串行）:
 * 1. ProvideData - 获取原始数据
 * 2. Preprocess - 预处理数据
 * 3. AISummarize - AI 摘要生成
 * 4. GenerateEmbedding - 生成向量嵌入
 * 5. InterestScore - 计算兴趣度评分
 */
// ...
const provideDataSuccess = await scheduleAndWaitForJob(TaskHandlerTypes.ProvideData, { /*...*/ }, POLL_INTERVAL, TASK_TIMEOUT);
// ...
const preprocessSuccess = await scheduleAndWaitForJob(TaskHandlerTypes.Preprocess, { /*...*/ }, POLL_INTERVAL, TASK_TIMEOUT);
// ...
```

### 1.2 “等待完成”的机制：不是 DAG 引擎，而是轮询 Mongo(Agenda jobs)

它用 `scheduleAndWaitForJob()`：先 `agendaInstance.now()` 立刻塞一个 job，然后轮询这个 jobId 的状态，直到 `lastFinishedAt` 或 `failedAt`。

```178:192:/synthos/common/scheduler/jobUtils.ts
export async function scheduleAndWaitForJob<T extends TaskHandlerTypes>(
    taskName: T,
    data: TaskParamsMap[T],
    pollIntervalMs: number,
    timeoutMs: number
): Promise<boolean> {
    LOGGER.info(`调度任务 [${taskName}]`);
    const job = await agendaInstance.now(taskName, data);
    return waitForJobCompletionByIdV3(job.attrs._id.toString(), pollIntervalMs, timeoutMs);
}
```

### 1.3 任务处理器分布在其它 apps 进程

- `ProvideData` 在 `applications/data-provider/src/index.ts` 里 `agendaInstance.define(...)`
- `Preprocess` 在 `applications/preprocessing/src/index.ts`
- `AISummarize/GenerateEmbedding/InterestScore/GenerateReport` 在 `applications/ai-model/src/tasks/*`

也就是说：**orchestrator 只是发号施令**；各任务由其它 Node 进程作为 worker 执行（共享同一个 MongoDB 的 `synthos_jobs` 集合）。

### 1.4 报告调度是独立子调度器

`orchestrator` 里还有 `setupReportScheduler()`：按 cron 配置定时 `agendaInstance.now(GenerateReport, ...)`。

```60:203:/synthos/applications/orchestrator/src/schedulers/reportScheduler.ts
await agendaInstance.every(cronExpression, `HalfDailyReport_${timeStr}`, {}, { skipImmediate: true });
// ...
agendaInstance.define(`HalfDailyReport_${timeStr}`, async () => {
  await agendaInstance.now(TaskHandlerTypes.GenerateReport, { reportType: "half-daily", timeStart, timeEnd });
});
```

# 需求概述

现在是“固定脚本串行调用”。我们要的“拖拽编排”本质需要两块能力：

1) **可视化建模**：拖拽节点、连线、配置节点参数（这是 UI / 模型）
2) **运行时执行器**：把图（DAG/流程）解释成一次次 job 调度，并处理：
   - 节点依赖（前置完成才运行）
   - 分支/并行/汇聚
   - 重试、超时、失败策略、跳过策略
   - 运行历史、可观测性
   - 支持**分支/并行/汇聚/条件判断**
   - 支持看到当前执行状态，运行到哪一步了

  现有代码可能已经包含部分上述逻辑（如检查网络连接、重试等），但是很分散且不好治理。

我们现在已有的只有：Agenda（定时/队列） + 一个“脚本式顺序控制”。

流程里节点类型需要覆盖现有 `TaskHandlerTypes`（ProvideData/Preprocess/...），也希望未来能“自定义脚本节点/HTTP 节点/循环”等。需要把各个任务执行期间的logger输出全部展示到前端页面。这需要：WebSocket 推送：后端实时推送日志行;关联流程执行 ID：每次 Pipeline 运行有唯一标识，日志带上这个 ID

我们希望流程定义存在哪里？继续沿用配置体系（`synthos_config_override.json`），好处是简单、可备份。

我们希望“编排 UI”集成到现有 `webui-frontend` 里（一个新页面）

# 具体实现

我打算使用 https://reactflow.dev/examples/overview 这个库。

需要订一个详细的、完备的流程编排契约！

可能涉及到applications\orchestrator和applications\webui-backend的tRPC通信

因为上述需求比较复杂，因此我想引入成熟的工作流和流程编排引擎。有没有什么强大的推荐？

请你先充分探索这个项目（并联网阅读https://reactflow.dev文档），然后和我讨论，以帮助我细化需求和技术细节。不要修改任何文件和代码！

尝试进行需求排期（因为一次肯定做不完这些东西！）
