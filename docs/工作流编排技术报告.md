# Synthos å·¥ä½œæµç¼–æ’æŠ€æœ¯æŠ¥å‘Š

> ç‰ˆæœ¬ï¼šv1.1
> æ›´æ–°æ—¥æœŸï¼š2026-02-07
> é€‚ç”¨å¯¹è±¡ï¼šSynthos å¼€å‘è€…ã€æ¶æ„å¸ˆ

---

## ğŸ“– ç›®å½•

1. [æŠ€æœ¯èƒŒæ™¯ä¸åŠ¨æœº](#1-æŠ€æœ¯èƒŒæ™¯ä¸åŠ¨æœº)
2. [ç³»ç»Ÿæ¶æ„è®¾è®¡](#2-ç³»ç»Ÿæ¶æ„è®¾è®¡)
3. [æ ¸å¿ƒæ¨¡å—è¯¦è§£](#3-æ ¸å¿ƒæ¨¡å—è¯¦è§£)
4. [æ•°æ®æµä¸æ‰§è¡Œæ¨¡å‹](#4-æ•°æ®æµä¸æ‰§è¡Œæ¨¡å‹)
5. [æŒä¹…åŒ–æ–¹æ¡ˆ](#5-æŒä¹…åŒ–æ–¹æ¡ˆ)
6. [tRPC é€šä¿¡é“¾è·¯](#6-trpc-é€šä¿¡é“¾è·¯)
7. [å‰ç«¯æŠ€æœ¯é€‰å‹](#7-å‰ç«¯æŠ€æœ¯é€‰å‹)
8. [æ€§èƒ½ä¸ä¼˜åŒ–](#8-æ€§èƒ½ä¸ä¼˜åŒ–)
9. [æµ‹è¯•ç­–ç•¥](#9-æµ‹è¯•ç­–ç•¥)
10. [æ‰©å±•æ€§è®¾è®¡](#10-æ‰©å±•æ€§è®¾è®¡)
11. [å·²çŸ¥é—®é¢˜ä¸æœªæ¥è§„åˆ’](#11-å·²çŸ¥é—®é¢˜ä¸æœªæ¥è§„åˆ’)

---

## 1. æŠ€æœ¯èƒŒæ™¯ä¸åŠ¨æœº

### 1.1 æ”¹é€ å‰çš„é—®é¢˜

åœ¨å¼•å…¥å·¥ä½œæµå¼•æ“ä¹‹å‰ï¼ŒSynthos çš„ `orchestrator` æ¨¡å—é‡‡ç”¨ **ç¡¬ç¼–ç è„šæœ¬å¼** çš„ä»»åŠ¡ç¼–æ’æ–¹å¼ï¼š

```typescript
// æ—§ä»£ç ï¼ˆå·²åºŸå¼ƒï¼‰
const provideDataSuccess = await scheduleAndWaitForJob(TaskHandlerTypes.ProvideData, {...});
if (!provideDataSuccess) throw new Error("ProvideData å¤±è´¥");

const preprocessSuccess = await scheduleAndWaitForJob(TaskHandlerTypes.Preprocess, {...});
if (!preprocessSuccess) throw new Error("Preprocess å¤±è´¥");

// ... 5 æ­¥ä¸²è¡Œé€»è¾‘
```

**ä¸»è¦é—®é¢˜**ï¼š
1. **ç¼ºä¹çµæ´»æ€§**ï¼šæµç¨‹å›ºå®šåœ¨ä»£ç ä¸­ï¼Œä¿®æ”¹éœ€è¦é‡æ–°ç¼–è¯‘éƒ¨ç½²
2. **æ— æ³•å¹¶è¡Œ**ï¼šå³ä½¿ `GenerateEmbedding` å’Œ `InterestScore` å¯ä»¥å¹¶è¡Œï¼Œä¹Ÿåªèƒ½ä¸²è¡Œæ‰§è¡Œ
3. **æ— æ¡ä»¶åˆ†æ”¯**ï¼šæ— æ³•æ ¹æ®è¿è¡Œæ—¶çŠ¶æ€åŠ¨æ€é€‰æ‹©è·¯å¾„
4. **éš¾ä»¥å¤ç”¨**ï¼šæ¯æ¬¡æ–°å¢æµç¨‹éƒ½éœ€è¦å†™ä¸€éè°ƒåº¦é€»è¾‘
5. **å¯è§‚æµ‹æ€§å·®**ï¼šç¼ºå°‘ç»Ÿä¸€çš„æ‰§è¡ŒçŠ¶æ€ç®¡ç†å’Œç›‘æ§
6. **æ–­ç‚¹ç»­è·‘å›°éš¾**ï¼šæµç¨‹å¤±è´¥åéœ€è¦ä»å¤´é‡è·‘

### 1.2 å¼•å…¥å·¥ä½œæµå¼•æ“çš„ç›®æ ‡

**æ ¸å¿ƒç›®æ ‡**ï¼š
- âœ… **å¯è§†åŒ–ç¼–æ’**ï¼šé€šè¿‡æ‹–æ‹½èŠ‚ç‚¹å’Œè¿çº¿å®šä¹‰æµç¨‹ï¼Œæ— éœ€ç¼–ç 
- âœ… **å¹¶è¡Œæ‰§è¡Œ**ï¼šæ”¯æŒ DAG çš„å¹¶è¡Œåˆ†æ”¯ï¼Œæå‡ååé‡
- âœ… **æ¡ä»¶åˆ†æ”¯**ï¼šæ ¹æ®èŠ‚ç‚¹è¾“å‡ºåŠ¨æ€å†³å®šè·¯å¾„
- âœ… **æ–­ç‚¹ç»­è·‘**ï¼šæŒä¹…åŒ–æ‰§è¡ŒçŠ¶æ€ï¼Œå¤±è´¥åä»æ–­ç‚¹æ¢å¤
- âœ… **å®æ—¶ç›‘æ§**ï¼štRPC subscription æ¨é€èŠ‚ç‚¹çŠ¶æ€å˜åŒ–
- âœ… **è§£è€¦è®¾è®¡**ï¼šå¼•æ“ä¸å…·ä½“ä»»åŠ¡è§£è€¦ï¼Œé€šè¿‡é€‚é…å™¨æ¨¡å¼é›†æˆ Agenda

### 1.3 æŠ€æœ¯é€‰å‹åŸåˆ™

| å†³ç­–ç‚¹ | é€‰å‹ç»“æœ | ç†ç”± |
|--------|---------|------|
| **å¼•æ“æ¨¡å¼** | è‡ªç ” DAG å¼•æ“ | ç°æœ‰å¼€æºæ–¹æ¡ˆï¼ˆå¦‚ Temporalã€n8nï¼‰è¿‡é‡ï¼Œè‡ªç ”å¯ç²¾ç¡®æ§åˆ¶ä¸ Agenda çš„é›†æˆè¾¹ç•Œ |
| **å‰ç«¯æ¡†æ¶** | React Flow v12 | æˆç†Ÿçš„æµç¨‹å›¾åº“ï¼Œæ”¯æŒæ‹–æ‹½ã€ç¼©æ”¾ã€è‡ªå®šä¹‰èŠ‚ç‚¹ï¼Œç¤¾åŒºæ´»è·ƒ |
| **çŠ¶æ€ç®¡ç†** | Zustand | è½»é‡çº§ï¼ˆ3KBï¼‰ï¼ŒReact Flow å®˜æ–¹æ¨èï¼Œæ—  Redux çš„ç¹çæ ·æ¿ä»£ç  |
| **é€šä¿¡åè®®** | tRPC (HTTP + WebSocket) | ç±»å‹å®‰å…¨çš„ RPC æ¡†æ¶ï¼Œæ”¯æŒ subscription å®æ—¶æ¨é€ |
| **æŒä¹…åŒ–** | SQLite | è½»é‡çº§ï¼Œæ— éœ€é¢å¤–æœåŠ¡ï¼Œæ”¯æŒ ACID äº‹åŠ¡ |
| **æ‹“æ‰‘æ’åºç®—æ³•** | Kahn ç®—æ³• | ç»å…¸ DAG æ‹“æ‰‘æ’åºç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ O(V+E) |

---

## 2. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         WebUI Frontend                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ React Flow   â”‚  â”‚ Zustand      â”‚  â”‚ tRPC Client          â”‚   â”‚
â”‚  â”‚ ç”»å¸ƒ/èŠ‚ç‚¹ç»„ä»¶ â”‚  â”‚ å·¥ä½œæµçŠ¶æ€    â”‚  â”‚ (WebSocket)          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚ HTTP/WS (:3002/trpc)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       WebUI Backend                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ tRPC Router (è½¬å‘å±‚)                                      â”‚   â”‚
â”‚  â”‚  - /trpc/listWorkflows                                   â”‚   â”‚
â”‚  â”‚  - /trpc/triggerWorkflow                                 â”‚   â”‚
â”‚  â”‚  - /trpc/onExecutionUpdate (subscription)                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ tRPC Client
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Orchestrator                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ tRPC Server (:8081)                                    â”‚     â”‚
â”‚  â”‚  - OrchestratorRPCImpl                                 â”‚     â”‚
â”‚  â”‚  - EventEmitter â†’ WebSocket æ¨é€                       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                 â”‚                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ WorkflowExecutor (äº‹ä»¶é©±åŠ¨ DAG å¼•æ“)                    â”‚     â”‚
â”‚  â”‚  - DagParser (æ‹“æ‰‘æ’åºã€ç¯æ£€æµ‹)                         â”‚     â”‚
â”‚  â”‚  - ExecutionContext (èŠ‚ç‚¹è¾“å‡ºå­˜å‚¨)                      â”‚     â”‚
â”‚  â”‚  - NodeExecutionStrategy (é‡è¯•/è¶…æ—¶)                   â”‚     â”‚
â”‚  â”‚  - ConditionEvaluator (æ¡ä»¶åˆ†æ”¯)                       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                 â”‚                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ AgendaNodeExecutorAdapter                              â”‚     â”‚
â”‚  â”‚  - è°ƒç”¨ agendaInstance.now()                           â”‚     â”‚
â”‚  â”‚  - è½®è¯¢ MongoDB (Agenda jobs é›†åˆ)                      â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                 â”‚                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ ExecutionPersistence (SQLite)                          â”‚     â”‚
â”‚  â”‚  - ä¿å­˜æ‰§è¡Œå¿«ç…§ (WorkflowExecution)                     â”‚     â”‚
â”‚  â”‚  - æ”¯æŒæ–­ç‚¹ç»­è·‘                                         â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â”‚ MongoDB
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Agenda Jobs                                  â”‚
â”‚  - ProvideData / Preprocess / AISummarize / ...                 â”‚
â”‚  - åˆ†å¸ƒåœ¨ data-provider, preprocessing, ai-model è¿›ç¨‹            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒè®¾è®¡åŸåˆ™

#### 2.2.1 ä¾èµ–å€’ç½®ï¼ˆDependency Inversionï¼‰

å¼•æ“ä¸ä¾èµ–å…·ä½“ä»»åŠ¡å®ç°ï¼Œé€šè¿‡ `NodeExecutorAdapter` æ¥å£è§£è€¦ï¼š

```typescript
interface NodeExecutorAdapter {
    executeTaskNode(nodeId: string, taskType: string, params: Record<string, any>, context: ExecutionContext): Promise<NodeExecutionResult>;
    executeScriptNode(nodeId: string, scriptCode: string, context: ExecutionContext): Promise<NodeExecutionResult>;
    executeHttpNode(nodeId: string, httpConfig: HttpNodeConfig, context: ExecutionContext): Promise<NodeExecutionResult>;
}
```

ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ `AgendaNodeExecutorAdapter`ï¼Œæµ‹è¯•ç¯å¢ƒå¯ä½¿ç”¨ `MockNodeExecutorAdapter`ã€‚

#### 2.2.2 äº‹ä»¶é©±åŠ¨ï¼ˆEvent-Drivenï¼‰

`WorkflowExecutor` ç»§æ‰¿è‡ª `EventEmitter`ï¼Œåœ¨å…³é”®èŠ‚ç‚¹å‘å°„äº‹ä»¶ï¼š

- `nodeStarted(nodeId, timestamp)`
- `nodeCompleted(nodeId, result)`
- `nodeFailed(nodeId, error)`
- `workflowCompleted(executionId)`
- `workflowFailed(executionId, error)`

å¤–éƒ¨è®¢é˜…è€…ï¼ˆå¦‚ tRPC Serverï¼‰ç›‘å¬è¿™äº›äº‹ä»¶å¹¶æ¨é€ç»™å‰ç«¯ã€‚

#### 2.2.3 çŠ¶æ€æŒä¹…åŒ–ï¼ˆPersistenceï¼‰

æ¯æ¬¡èŠ‚ç‚¹çŠ¶æ€å˜æ›´æ—¶ï¼Œç«‹å³ `upsert` åˆ° SQLiteï¼š

```typescript
await this._persistence.saveExecution({
    executionId,
    workflowId,
    status: "running",
    nodeStates: { [nodeId]: { status: "running", startedAt: Date.now() } },
    snapshot: structuredClone(workflowDefinition)
});
```

æ–­ç‚¹ç»­è·‘æ—¶ï¼Œä» SQLite æ¢å¤å¿«ç…§ï¼Œè·³è¿‡å·²å®Œæˆçš„èŠ‚ç‚¹ã€‚

---

## 3. æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 3.1 DagParserï¼ˆæ‹“æ‰‘æ’åºä¸æ ¡éªŒï¼‰

**èŒè´£**ï¼š
- è§£æ `nodes[]` + `edges[]` æ„å»ºé‚»æ¥è¡¨
- **Kahn ç®—æ³•** æ‹“æ‰‘æ’åºï¼Œç”Ÿæˆ `ExecutionPlan`ï¼ˆåˆ†å±‚èŠ‚ç‚¹åˆ—è¡¨ï¼‰
- **ç¯æ£€æµ‹**ï¼šæ‹“æ‰‘æ’åºåè‹¥æœ‰å‰©ä½™èŠ‚ç‚¹ï¼Œè¯´æ˜å­˜åœ¨ç¯
- **è¿é€šæ€§æ ¡éªŒ**ï¼šæ‰€æœ‰èŠ‚ç‚¹ä» start å¯è¾¾

**å…³é”®ä»£ç **ï¼š

```typescript
// applications/orchestrator/src/core/DagParser.ts
export class DagParser {
    public parse(definition: WorkflowDefinition): ExecutionPlan {
        // 1. æ„å»ºé‚»æ¥è¡¨å’Œå…¥åº¦è¡¨
        const adjList = new Map<string, string[]>();
        const inDegree = new Map<string, number>();
        
        // 2. Kahn ç®—æ³•æ‹“æ‰‘æ’åº
        const layers: string[][] = [];
        const queue: string[] = [];
        
        // å°†å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹å…¥é˜Ÿ
        for (const [nodeId, degree] of inDegree.entries()) {
            if (degree === 0) queue.push(nodeId);
        }
        
        while (queue.length > 0) {
            const currentLayer = [...queue];
            queue.length = 0;
            layers.push(currentLayer);
            
            for (const nodeId of currentLayer) {
                for (const neighbor of adjList.get(nodeId) || []) {
                    inDegree.set(neighbor, inDegree.get(neighbor)! - 1);
                    if (inDegree.get(neighbor) === 0) {
                        queue.push(neighbor);
                    }
                }
            }
        }
        
        // 3. ç¯æ£€æµ‹
        if (layers.flat().length !== definition.nodes.length) {
            throw new Error("å·¥ä½œæµå­˜åœ¨ç¯è·¯");
        }
        
        return { layers, adjacencyList: adjList };
    }
}
```

**æ—¶é—´å¤æ‚åº¦**ï¼šO(V + E)ï¼ŒV ä¸ºèŠ‚ç‚¹æ•°ï¼ŒE ä¸ºè¾¹æ•°ã€‚

### 3.2 WorkflowExecutorï¼ˆäº‹ä»¶é©±åŠ¨æ‰§è¡Œå¼•æ“ï¼‰

**èŒè´£**ï¼š
- æ¥æ”¶ `WorkflowDefinition` å’Œ `NodeExecutorAdapter`
- æŒ‰æ‹“æ‰‘å±‚é€å±‚æ‰§è¡Œï¼ˆå±‚å†…å¹¶è¡Œï¼‰
- å¤„ç†æ¡ä»¶åˆ†æ”¯ã€æ±‡èšèŠ‚ç‚¹
- å‘å°„äº‹ä»¶ä¾›å¤–éƒ¨è®¢é˜…

**æ‰§è¡Œæµç¨‹**ï¼š

```typescript
// applications/orchestrator/src/core/WorkflowExecutor.ts
export class WorkflowExecutor extends EventEmitter {
    public async execute(definition: WorkflowDefinition, globalVars?: Record<string, any>): Promise<WorkflowExecution> {
        const executionId = uuidv4();
        const snapshot = structuredClone(definition); // æ·±æ‹·è´å¿«ç…§
        const context = new ExecutionContext(globalVars);
        
        // 1. æ‹“æ‰‘æ’åº
        const plan = this._dagParser.parse(snapshot);
        
        // 2. åˆå§‹åŒ–æŒä¹…åŒ–è®°å½•
        await this._persistence.saveExecution({
            executionId,
            workflowId: definition.id,
            status: "running",
            nodeStates: {},
            startedAt: Date.now(),
            snapshot
        });
        
        // 3. é€å±‚æ‰§è¡Œ
        for (const layer of plan.layers) {
            // å±‚å†…å¹¶è¡Œæ‰§è¡Œï¼ˆPromise.allSettledï¼‰
            const promises = layer.map(nodeId => this._executeNode(nodeId, snapshot, context, executionId));
            await Promise.allSettled(promises);
        }
        
        // 4. æ ‡è®°å®Œæˆ
        await this._persistence.updateExecutionStatus(executionId, "completed");
        this.emit("workflowCompleted", executionId);
        
        return await this._persistence.loadExecution(executionId);
    }
    
    private async _executeNode(nodeId: string, snapshot: WorkflowDefinition, context: ExecutionContext, executionId: string): Promise<void> {
        const node = snapshot.nodes.find(n => n.id === nodeId)!;
        
        this.emit("nodeStarted", nodeId, Date.now());
        
        try {
            // åº”ç”¨é‡è¯•/è¶…æ—¶ç­–ç•¥
            const result = await this._nodeStrategy.executeWithStrategy(node, context, this._adapter);
            
            // ä¿å­˜ç»“æœåˆ°ä¸Šä¸‹æ–‡
            context.setNodeResult(nodeId, result);
            
            // æŒä¹…åŒ–
            await this._persistence.saveNodeState(executionId, nodeId, { status: "success", ...result });
            
            this.emit("nodeCompleted", nodeId, result);
        } catch (error) {
            await this._persistence.saveNodeState(executionId, nodeId, { status: "failed", error: error.message });
            this.emit("nodeFailed", nodeId, error);
            
            // å¦‚æœæœªå¼€å¯ skipOnFailureï¼Œåˆ™ç»ˆæ­¢æµç¨‹
            if (!node.data.skipOnFailure) {
                throw error;
            }
        }
    }
}
```

### 3.3 ExecutionContextï¼ˆæ‰§è¡Œä¸Šä¸‹æ–‡ï¼‰

**èŒè´£**ï¼š
- å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„æ‰§è¡Œç»“æœï¼ˆè¾“å‡ºï¼‰
- æä¾› `getUpstreamOutput(nodeId)` æ–¹æ³•ä¾›ä¸‹æ¸¸èŠ‚ç‚¹è®¿é—®
- å­˜å‚¨å…¨å±€å˜é‡ï¼ˆå¦‚ `startTimeStamp`ã€`endTimeStamp`ï¼‰

**æ•°æ®ç»“æ„**ï¼š

```typescript
// applications/orchestrator/src/core/ExecutionContext.ts
export class ExecutionContext {
    private _nodeResults: Map<string, NodeExecutionResult> = new Map();
    private _globalVars: Map<string, any> = new Map();
    
    public setNodeResult(nodeId: string, result: NodeExecutionResult): void {
        this._nodeResults.set(nodeId, result);
    }
    
    public getUpstreamOutput(nodeId: string): any {
        const result = this._nodeResults.get(nodeId);
        if (!result) {
            throw new Error(`èŠ‚ç‚¹ ${nodeId} çš„è¾“å‡ºä¸å­˜åœ¨ï¼ˆå¯èƒ½å°šæœªæ‰§è¡Œï¼‰`);
        }
        return result.output;
    }
    
    public getGlobalVar(key: string): any {
        return this._globalVars.get(key);
    }
}
```

**é˜²è¯»å–è¿‡æ—¶æ•°æ®**ï¼šå¼•æ“æŒ‰æ‹“æ‰‘é¡ºåºæ‰§è¡Œï¼Œä¿è¯è¯»å–æ—¶ä¸Šæ¸¸èŠ‚ç‚¹å·²å®Œæˆã€‚

### 3.4 ConditionEvaluatorï¼ˆæ¡ä»¶åˆ†æ”¯é€»è¾‘ï¼‰

**èŒè´£**ï¼š
- æ ¹æ®æ¡ä»¶è¡¨è¾¾å¼æ±‚å€¼ï¼Œè¿”å› `true` / `false`
- æ”¯æŒ 4 ç§æ¡ä»¶ç±»å‹

**å®ç°**ï¼š

```typescript
// applications/orchestrator/src/core/ConditionEvaluator.ts
export class ConditionEvaluator {
    public evaluate(expression: ConditionExpression, context: ExecutionContext): boolean {
        switch (expression.type) {
            case "previousNodeSuccess":
                const prevNodeId = expression.nodeId;
                const prevResult = context.getNodeResult(prevNodeId);
                return prevResult.status === "success";
            
            case "previousNodeFailed":
                return context.getNodeResult(expression.nodeId).status === "failed";
            
            case "keyValueMatch":
                const output = context.getUpstreamOutput(expression.nodeId);
                return output[expression.key] === expression.value;
            
            case "customExpression":
                // ä½¿ç”¨ vm2 æˆ–ç±»ä¼¼æ²™ç®±æ‰§è¡Œç”¨æˆ·è‡ªå®šä¹‰ JS
                return this._evalCustomExpression(expression.code, context);
        }
    }
}
```

### 3.5 NodeExecutionStrategyï¼ˆé‡è¯•/è¶…æ—¶ç­–ç•¥ï¼‰

**èŒè´£**ï¼š
- å°è£…èŠ‚ç‚¹æ‰§è¡Œçš„é‡è¯•ã€è¶…æ—¶ã€è·³è¿‡é€»è¾‘
- è°ƒç”¨ `common/util/retryAsync.ts` å®ç°é‡è¯•

**å…³é”®ä»£ç **ï¼š

```typescript
// applications/orchestrator/src/core/NodeExecutionStrategy.ts
export class NodeExecutionStrategy {
    public async executeWithStrategy(node: WorkflowNode, context: ExecutionContext, adapter: NodeExecutorAdapter): Promise<NodeExecutionResult> {
        const { retryCount = 0, timeoutMs = 0, skipOnFailure = false } = node.data;
        
        const executeTask = async () => {
            const promise = adapter.executeTaskNode(node.id, node.data.taskType!, node.data.params || {}, context);
            
            if (timeoutMs > 0) {
                return Promise.race([
                    promise,
                    this._timeout(timeoutMs)
                ]);
            }
            
            return promise;
        };
        
        try {
            return await retryAsync(executeTask, retryCount, 1000);
        } catch (error) {
            if (skipOnFailure) {
                return { success: false, status: "skipped", error: error.message };
            }
            throw error;
        }
    }
    
    private _timeout(ms: number): Promise<never> {
        return new Promise((_, reject) => setTimeout(() => reject(new Error("æ‰§è¡Œè¶…æ—¶")), ms));
    }
}
```

### 3.6 TaskParamsResolverï¼ˆä»»åŠ¡å‚æ•°è§£æï¼‰

**èŒè´£**ï¼š
- åˆå¹¶èŠ‚ç‚¹é…ç½®å‚æ•°ã€æ‰§è¡Œä¸Šä¸‹æ–‡å‚æ•°ã€å…¨å±€é»˜è®¤å‚æ•°
- ä¸ºæ¯ä¸ªä»»åŠ¡ç±»å‹ç”Ÿæˆå®Œæ•´çš„å‚æ•°å¯¹è±¡
- å®ç°å‚æ•°ä¼˜å…ˆçº§æœºåˆ¶

**å‚æ•°ä¼˜å…ˆçº§**ï¼ˆä»é«˜åˆ°ä½ï¼‰ï¼š
1. **èŠ‚ç‚¹é…ç½®å‚æ•°**ï¼šåœ¨å‰ç«¯å±æ€§é¢æ¿ä¸­ä¸ºèŠ‚ç‚¹ç›´æ¥é…ç½®çš„å‚æ•°
2. **æ‰§è¡Œä¸Šä¸‹æ–‡å‚æ•°**ï¼šå·¥ä½œæµæ‰§è¡Œæ—¶åŠ¨æ€æ³¨å…¥çš„å‚æ•°ï¼ˆå¦‚ä¸Šæ¸¸èŠ‚ç‚¹è¾“å‡ºï¼‰
3. **å…¨å±€é»˜è®¤å‚æ•°**ï¼šåœ¨ `synthos_config.json` çš„ `orchestrator` é…ç½®ä¸­å®šä¹‰

**å®ç°ç¤ºä¾‹**ï¼š

```typescript
// applications/orchestrator/src/core/TaskParamsResolver.ts
@injectable()
export class TaskParamsResolver {
    public constructor(
        @inject(COMMON_TOKENS.ConfigManagerService) private configManagerService: ConfigManagerService
    ) {}
    
    public async resolveParams<T extends TaskHandlerTypes>(
        taskType: T,
        nodeParams: Record<string, any>,
        context: ExecutionContext
    ): Promise<TaskParamsMap[T]> {
        // 1. ç”Ÿæˆé»˜è®¤å‚æ•°
        const defaultParams = await this._generateDefaultParams(taskType, context);
        
        // 2. åˆå¹¶èŠ‚ç‚¹å‚æ•°ï¼ˆèŠ‚ç‚¹å‚æ•°ä¼˜å…ˆçº§æ›´é«˜ï¼‰
        const mergedParams = { ...defaultParams, ...nodeParams };
        
        return mergedParams as TaskParamsMap[T];
    }
    
    private async _generateDefaultParams(
        taskType: TaskHandlerTypes,
        context: ExecutionContext
    ): Promise<Record<string, any>> {
        const config = await this.configManagerService.getCurrentConfig();
        
        // ä»ä¸Šä¸‹æ–‡æˆ–é…ç½®ç”Ÿæˆæ—¶é—´èŒƒå›´
        let startTimeStamp = context.getGlobalVar("startTimeStamp") as number | undefined;
        let endTimeStamp = context.getGlobalVar("endTimeStamp") as number | undefined;
        
        if (!startTimeStamp || !endTimeStamp) {
            const hoursToCheck = config.orchestrator.defaultTimeRangeInHours || 24;
            endTimeStamp = Date.now();
            startTimeStamp = endTimeStamp - hoursToCheck * 60 * 60 * 1000;
            
            // ä¿å­˜åˆ°ä¸Šä¸‹æ–‡ä¾›åç»­èŠ‚ç‚¹ä½¿ç”¨
            context.setGlobalVar("startTimeStamp", startTimeStamp);
            context.setGlobalVar("endTimeStamp", endTimeStamp);
        }
        
        // ä»ä¸Šä¸‹æ–‡æˆ–é…ç½®ç”Ÿæˆ groupIds
        let groupIds = context.getGlobalVar("groupIds") as string[] | undefined;
        if (!groupIds) {
            groupIds = config.orchestrator.defaultGroupIds || [];
            context.setGlobalVar("groupIds", groupIds);
        }
        
        // æ ¹æ®ä»»åŠ¡ç±»å‹ç”Ÿæˆé»˜è®¤å‚æ•°
        switch (taskType) {
            case TaskHandlerTypes.ProvideData:
                return {
                    IMType: config.orchestrator.defaultIMType || IMTypes.QQ,
                    groupIds,
                    startTimeStamp,
                    endTimeStamp
                };
            case TaskHandlerTypes.AISummarize:
                return { groupIds, startTimeStamp, endTimeStamp };
            // ... å…¶ä»–ä»»åŠ¡ç±»å‹
        }
    }
}
```

**é…ç½®æ–‡ä»¶ç¤ºä¾‹**ï¼š

```json
{
  "orchestrator": {
    "defaultTimeRangeInHours": 100,
    "defaultGroupIds": ["12345678", "87654321"],
    "defaultIMType": "QQ"
  }
}
```

**å‰ç«¯å‚æ•°é…ç½®ç•Œé¢**ï¼š
- **ä»»åŠ¡èŠ‚ç‚¹å±æ€§é¢æ¿**ï¼šæ ¹æ®ä»»åŠ¡ç±»å‹åŠ¨æ€å±•ç¤ºå‚æ•°è¡¨å•ï¼ˆgroupIdsã€startTimeStampã€endTimeStampã€IMTypeã€reportType ç­‰ï¼‰
- **å…¨å±€å‚æ•°è®¾ç½®æŒ‰é’®**ï¼šåœ¨å·¥ä½œæµé¡µé¢å·¥å…·æ ï¼Œå¯ç¼–è¾‘ `defaultTimeRangeInHours`ã€`defaultGroupIds`ã€`defaultIMType`

### 3.7 ExecutionPersistenceï¼ˆSQLite æŒä¹…åŒ–ï¼‰

**èŒè´£**ï¼š
- åˆ›å»º SQLite æ•°æ®åº“ `synthos_workflow_executions.db`
- å­˜å‚¨ `WorkflowExecution` è¡¨
- æä¾› `saveExecution`ã€`loadExecution`ã€`listExecutions` æ–¹æ³•

**Schema**ï¼š

```sql
CREATE TABLE workflow_executions (
    execution_id TEXT PRIMARY KEY,
    workflow_id TEXT NOT NULL,
    status TEXT NOT NULL,  -- "pending" | "running" | "completed" | "failed"
    node_states TEXT,      -- JSON
    started_at INTEGER,
    completed_at INTEGER,
    snapshot TEXT          -- JSONï¼ˆå·¥ä½œæµå®šä¹‰å¿«ç…§ï¼‰
);
```

**æ–­ç‚¹ç»­è·‘å®ç°**ï¼š

```typescript
public async resumeExecution(executionId: string): Promise<WorkflowExecution> {
    const execution = await this.loadExecution(executionId);
    if (!execution) {
        throw new Error("æ‰§è¡Œè®°å½•ä¸å­˜åœ¨");
    }
    
    // è·³è¿‡å·²å®Œæˆçš„èŠ‚ç‚¹
    const completedNodes = Object.keys(execution.nodeStates).filter(
        nodeId => execution.nodeStates[nodeId].status === "success"
    );
    
    // é‡æ–°æ‰§è¡Œå¤±è´¥/å–æ¶ˆçš„èŠ‚ç‚¹
    const restartNodes = Object.keys(execution.nodeStates).filter(
        nodeId => ["failed", "cancelled"].includes(execution.nodeStates[nodeId].status)
    );
    
    // è°ƒç”¨ WorkflowExecutor ç»§ç»­æ‰§è¡Œ
    return this._executor.resume(execution.snapshot, completedNodes, restartNodes);
}
```

---

## 4. æ•°æ®æµä¸æ‰§è¡Œæ¨¡å‹

### 4.1 ç«¯åˆ°ç«¯æ•°æ®æµ

```
1. ç”¨æˆ·åœ¨å‰ç«¯æ‹–æ‹½èŠ‚ç‚¹ â†’ ç”Ÿæˆ WorkflowDefinition JSON
2. ç‚¹å‡»"ä¿å­˜" â†’ POST /api/workflow/save â†’ å†™å…¥ synthos_config.json
3. ç‚¹å‡»"æ‰‹åŠ¨è§¦å‘" â†’ POST /api/workflow/trigger â†’ tRPC Client
4. tRPC Client â†’ Orchestrator tRPC Server â†’ WorkflowExecutor.execute()
5. Executor è§£æ DAG â†’ é€å±‚æ‰§è¡ŒèŠ‚ç‚¹
6. æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œæ—¶ â†’ AgendaNodeExecutorAdapter.executeTaskNode()
7. Adapter è°ƒç”¨ agendaInstance.now() â†’ ä»»åŠ¡è¿›å…¥ Agenda é˜Ÿåˆ—
8. Adapter è½®è¯¢ MongoDB (Agenda jobs) ç­‰å¾…ä»»åŠ¡å®Œæˆ
9. ä»»åŠ¡å®Œæˆå â†’ æ›´æ–° ExecutionContext + æŒä¹…åŒ–åˆ° SQLite
10. Executor å‘å°„ nodeCompleted äº‹ä»¶ â†’ tRPC Server æ¨é€ç»™å‰ç«¯
11. å‰ç«¯ WebSocket æ”¶åˆ°äº‹ä»¶ â†’ æ›´æ–° Zustand store â†’ React Flow èŠ‚ç‚¹é‡æ–°æ¸²æŸ“
```

### 4.2 å¹¶è¡Œæ‰§è¡Œæ¨¡å‹

Kahn ç®—æ³•ç”Ÿæˆçš„ `ExecutionPlan` æ˜¯ä¸€ä¸ª**åˆ†å±‚åˆ—è¡¨**ï¼š

```typescript
{
  layers: [
    ["start"],                    // ç¬¬ 0 å±‚ï¼šèµ·å§‹èŠ‚ç‚¹
    ["provide-data"],             // ç¬¬ 1 å±‚
    ["preprocess"],               // ç¬¬ 2 å±‚
    ["ai-summarize"],             // ç¬¬ 3 å±‚
    ["generate-embedding", "interest-score"],  // ç¬¬ 4 å±‚ï¼šå¹¶è¡Œ
    ["end"]                       // ç¬¬ 5 å±‚
  ]
}
```

**å…³é”®ç‚¹**ï¼š
- æ¯å±‚å†…çš„èŠ‚ç‚¹ **å®Œå…¨ç‹¬ç«‹**ï¼Œå¯ä»¥å¹¶è¡Œæ‰§è¡Œ
- ä½¿ç”¨ `Promise.allSettled()` å¹¶å‘è°ƒç”¨ï¼Œé¿å…ä¸€ä¸ªèŠ‚ç‚¹å¤±è´¥å¯¼è‡´å…¶ä»–èŠ‚ç‚¹è¢«å–æ¶ˆ
- å±‚ä¸å±‚ä¹‹é—´ä¸¥æ ¼ä¸²è¡Œï¼Œä¿è¯ä¾èµ–å…³ç³»

### 4.3 æ¡ä»¶åˆ†æ”¯æ‰§è¡Œæ¨¡å‹

æ¡ä»¶èŠ‚ç‚¹æœ‰å¤šæ¡å‡ºè¾¹ï¼Œæ‰§è¡Œæ—¶ï¼š

1. æ±‚å€¼æ¡ä»¶è¡¨è¾¾å¼ â†’ å¾—åˆ° `true` / `false`
2. æ ¹æ®ç»“æœé€‰æ‹©å¯¹åº”çš„å‡ºè¾¹
3. **åªæ‰§è¡Œé€‰ä¸­åˆ†æ”¯** çš„ä¸‹æ¸¸èŠ‚ç‚¹
4. æœªé€‰ä¸­åˆ†æ”¯çš„ä¸‹æ¸¸èŠ‚ç‚¹çŠ¶æ€æ ‡è®°ä¸º `skipped`

**ç¤ºä¾‹**ï¼š

```
[ProvideData] â†’ [Condition]
                  â”œâ”€â”€ true â†’ [Preprocess]
                  â””â”€â”€ false â†’ [AISummarize]
```

å¦‚æœæ¡ä»¶æ±‚å€¼ä¸º `false`ï¼Œåˆ™ `Preprocess` èŠ‚ç‚¹è¢«è·³è¿‡ï¼Œç›´æ¥æ‰§è¡Œ `AISummarize`ã€‚

---

## 5. æŒä¹…åŒ–æ–¹æ¡ˆ

### 5.1 ä¸ºä»€ä¹ˆé€‰æ‹© SQLite

| å¯¹æ¯”é¡¹ | SQLite | MongoDB |
|--------|--------|---------|
| **éƒ¨ç½²å¤æ‚åº¦** | âœ… å•æ–‡ä»¶ï¼Œæ— éœ€ç‹¬ç«‹æœåŠ¡ | âŒ éœ€è¦ MongoDB æœåŠ¡ |
| **ACID äº‹åŠ¡** | âœ… æ”¯æŒ | âœ… æ”¯æŒ |
| **æŸ¥è¯¢çµæ´»æ€§** | âœ… æ ‡å‡† SQL | âš ï¸ BSON æŸ¥è¯¢è¯­æ³• |
| **å¤‡ä»½** | âœ… ç›´æ¥å¤åˆ¶æ–‡ä»¶ | âŒ éœ€è¦ mongodump |
| **é€‚ç”¨åœºæ™¯** | âœ… æœ¬åœ°æŒä¹…åŒ–ã€å†å²å›æº¯ | âœ… åˆ†å¸ƒå¼ã€é«˜å¹¶å‘ |

è€ƒè™‘åˆ°å·¥ä½œæµæ‰§è¡Œè®°å½•é€šå¸¸åœ¨**å•æœºç¯å¢ƒ**ä¸‹æŸ¥è¯¢ï¼ˆä¸éœ€è¦åˆ†å¸ƒå¼ï¼‰ï¼Œä¸”æ•°æ®é‡ä¸å¤§ï¼ˆæ¯æ¬¡æ‰§è¡Œä¸€æ¡è®°å½•ï¼‰ï¼ŒSQLite æ›´è½»é‡ã€‚

### 5.2 æ•°æ®åº“Schemaè®¾è®¡

#### è¡¨ï¼šworkflow_executions

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `execution_id` | TEXT (PK) | UUIDï¼Œå”¯ä¸€æ ‡è¯†æ¯æ¬¡æ‰§è¡Œ |
| `workflow_id` | TEXT | å·¥ä½œæµ IDï¼ˆæ¥è‡ª synthos_config.jsonï¼‰ |
| `status` | TEXT | "pending" / "running" / "completed" / "failed" |
| `node_states` | TEXT (JSON) | å„èŠ‚ç‚¹çŠ¶æ€ï¼š`{ [nodeId]: { status, startedAt, completedAt, output, error } }` |
| `started_at` | INTEGER | å¼€å§‹æ—¶é—´ï¼ˆUNIX æ¯«ç§’æ—¶é—´æˆ³ï¼‰ |
| `completed_at` | INTEGER | å®Œæˆæ—¶é—´ |
| `snapshot` | TEXT (JSON) | å·¥ä½œæµå®šä¹‰å¿«ç…§ï¼ˆæ·±æ‹·è´ï¼‰ |

#### ç´¢å¼•

```sql
CREATE INDEX idx_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_status ON workflow_executions(status);
CREATE INDEX idx_started_at ON workflow_executions(started_at DESC);
```

### 5.3 è¿è¡Œæ—¶å¿«ç…§æœºåˆ¶

**é—®é¢˜**ï¼šå¦‚æœç”¨æˆ·åœ¨å·¥ä½œæµè¿è¡ŒæœŸé—´ä¿®æ”¹äº†å·¥ä½œæµå®šä¹‰ï¼Œä¼šå¯¼è‡´æ‰§è¡ŒçŠ¶æ€ä¸å®šä¹‰ä¸ä¸€è‡´ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼šæ‰§è¡Œå™¨å¯åŠ¨æ—¶ï¼Œç«‹å³ `structuredClone(workflowDefinition)` åˆ›å»ºå¿«ç…§ï¼Œä¿å­˜åˆ° SQLite çš„ `snapshot` å­—æ®µã€‚æ‰§è¡ŒæœŸé—´å®Œå…¨åŸºäºå¿«ç…§è¿è¡Œï¼Œä¸å—å¤–éƒ¨ä¿®æ”¹å½±å“ã€‚

---

## 6. tRPC é€šä¿¡é“¾è·¯

### 6.1 æ¶æ„åˆ†å±‚

```
Frontend (React)
    â†“ tRPC Client (WebSocket)
WebUI-Backend (:3002/trpc)
    â†“ tRPC Client (è½¬å‘)
Orchestrator (:8081)
    â†“ tRPC Server
```

**ä¸ºä»€ä¹ˆè¦åˆ†ä¸¤å±‚ï¼Ÿ**
1. **å®‰å…¨éš”ç¦»**ï¼šå‰ç«¯ä¸ç›´æ¥è®¿é—® Orchestratorï¼Œæ‰€æœ‰è¯·æ±‚ç»è¿‡ webui-backend ç»Ÿä¸€é‰´æƒ
2. **åè®®è½¬æ¢**ï¼šwebui-backend å¯ä»¥å°† REST è¯·æ±‚è½¬æ¢ä¸º tRPC è°ƒç”¨
3. **ç»Ÿä¸€ç½‘å…³**ï¼šæœªæ¥å¯ä»¥åœ¨ webui-backend å±‚å®ç°é™æµã€æ—¥å¿—ã€ç›‘æ§ç­‰ä¸­é—´ä»¶

### 6.2 tRPC Router å®šä¹‰

```typescript
// common/rpc/orchestrator/router.ts
export function createOrchestratorRouter(impl: OrchestratorRPCImplementation) {
    return t.router({
        // Query: æŸ¥è¯¢ç±»æ¥å£
        listWorkflows: t.procedure
            .output(ListWorkflowsOutputSchema)
            .query(async () => impl.listWorkflows()),
        
        getWorkflow: t.procedure
            .input(GetWorkflowInputSchema)
            .output(GetWorkflowOutputSchema)
            .query(async ({ input }) => impl.getWorkflow(input)),
        
        // Mutation: å˜æ›´ç±»æ¥å£
        triggerWorkflow: t.procedure
            .input(TriggerWorkflowInputSchema)
            .output(TriggerWorkflowOutputSchema)
            .mutation(async ({ input }) => impl.triggerWorkflow(input)),
        
        // Subscription: å®æ—¶æ¨é€
        onExecutionUpdate: t.procedure
            .input(OnExecutionUpdateInputSchema)
            .subscription(async ({ input }) => {
                return observable<ExecutionUpdateEvent>((emit) => {
                    const listener = (event: ExecutionUpdateEvent) => {
                        if (event.executionId === input.executionId) {
                            emit.next(event);
                        }
                    };
                    
                    impl.subscribeToExecutionUpdates(listener);
                    
                    return () => {
                        impl.unsubscribeFromExecutionUpdates(listener);
                    };
                });
            })
    });
}
```

### 6.3 å‰ç«¯ Subscription ç¤ºä¾‹

```typescript
// applications/webui-frontend/src/pages/workflow/hooks/useExecutionStatus.ts
import { trpc } from '@/api/trpcClient';

export function useExecutionStatus(executionId: string) {
    const [nodeStates, setNodeStates] = useState<Record<string, NodeState>>({});
    
    useEffect(() => {
        const subscription = trpc.onExecutionUpdate.subscribe(
            { executionId },
            {
                onData(event) {
                    if (event.type === "nodeCompleted") {
                        setNodeStates(prev => ({
                            ...prev,
                            [event.nodeId]: { status: "success", ...event.result }
                        }));
                    }
                },
                onError(err) {
                    console.error("è®¢é˜…é”™è¯¯:", err);
                }
            }
        );
        
        return () => subscription.unsubscribe();
    }, [executionId]);
    
    return nodeStates;
}
```

---

## 7. å‰ç«¯æŠ€æœ¯é€‰å‹

### 7.1 React Flow v12

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
- æ‹–æ‹½èŠ‚ç‚¹å’Œè¿çº¿
- è‡ªåŠ¨å¸ƒå±€ï¼ˆå¯é€‰ï¼‰
- ç¼©æ”¾ã€å¹³ç§»ã€å°åœ°å›¾
- è‡ªå®šä¹‰èŠ‚ç‚¹ç»„ä»¶

**è‡ªå®šä¹‰èŠ‚ç‚¹ç¤ºä¾‹**ï¼š

```tsx
// applications/webui-frontend/src/pages/workflow/nodes/TaskNode.tsx
import { memo } from 'react';
import { Handle, Position, NodeProps } from '@xyflow/react';

export const TaskNode = memo(({ data }: NodeProps) => {
    const statusColor = {
        pending: 'border-gray-400',
        running: 'border-blue-500 animate-pulse',
        success: 'border-green-500',
        failed: 'border-red-500'
    }[data.status || 'pending'];
    
    return (
        <div className={`px-4 py-2 rounded border-2 ${statusColor} bg-white`}>
            <Handle type="target" position={Position.Left} />
            <div className="text-sm font-medium">{data.label}</div>
            <div className="text-xs text-gray-500">{data.taskType}</div>
            <Handle type="source" position={Position.Right} />
        </div>
    );
});
```

### 7.2 Zustand çŠ¶æ€ç®¡ç†

**ä¸ºä»€ä¹ˆä¸ç”¨ Reduxï¼Ÿ**
- Redux éœ€è¦å¤§é‡æ ·æ¿ä»£ç ï¼ˆactionsã€reducersã€storeï¼‰
- Zustand ä»… 3KBï¼ŒAPI æç®€
- React Flow å®˜æ–¹æ¨è

**Store ç¤ºä¾‹**ï¼š

```typescript
// applications/webui-frontend/src/pages/workflow/stores/workflowStore.ts
import { create } from 'zustand';

interface WorkflowStore {
    nodes: Node[];
    edges: Edge[];
    selectedNodeId: string | null;
    setNodes: (nodes: Node[]) => void;
    setEdges: (edges: Edge[]) => void;
    updateNodeData: (nodeId: string, data: Partial<NodeData>) => void;
}

export const useWorkflowStore = create<WorkflowStore>((set) => ({
    nodes: [],
    edges: [],
    selectedNodeId: null,
    
    setNodes: (nodes) => set({ nodes }),
    setEdges: (edges) => set({ edges }),
    
    updateNodeData: (nodeId, data) => set((state) => ({
        nodes: state.nodes.map(node =>
            node.id === nodeId ? { ...node, data: { ...node.data, ...data } } : node
        )
    }))
}));
```

### 7.3 Monaco Editor é›†æˆï¼ˆè„šæœ¬èŠ‚ç‚¹ï¼‰

è„šæœ¬èŠ‚ç‚¹éœ€è¦å†…åµŒä»£ç ç¼–è¾‘å™¨ï¼Œå¤ç”¨é¡¹ç›®ä¸­å·²æœ‰çš„ `@monaco-editor/react`ï¼š

```tsx
// applications/webui-frontend/src/pages/workflow/components/property-forms/ScriptPropertyForm.tsx
import Editor from '@monaco-editor/react';

export function ScriptPropertyForm({ node, onChange }) {
    return (
        <div className="h-64">
            <Editor
                height="100%"
                language="javascript"
                theme="vs-dark"
                value={node.data.scriptCode || ''}
                onChange={(value) => onChange({ scriptCode: value })}
                options={{
                    minimap: { enabled: false },
                    lineNumbers: 'on',
                    tabSize: 2
                }}
            />
        </div>
    );
}
```

---

## 8. æ€§èƒ½ä¸ä¼˜åŒ–

### 8.1 å¹¶å‘æ§åˆ¶

**é—®é¢˜**ï¼šé»˜è®¤ Agenda `maxConcurrency: 1`ï¼Œæ‰€æœ‰ä»»åŠ¡ä¸²è¡Œæ‰§è¡Œï¼Œæ— æ³•åˆ©ç”¨ DAG çš„å¹¶è¡Œèƒ½åŠ›ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. è°ƒé«˜ Agenda çš„ `maxConcurrency` é…ç½®ï¼ˆå¦‚è®¾ä¸º 5ï¼‰
2. åœ¨ `AgendaNodeExecutorAdapter` ä¸­å®ç°å¹¶å‘æ§åˆ¶ï¼š

```typescript
class AgendaNodeExecutorAdapter {
    private _concurrencySemaphore = new Semaphore(5);
    
    async executeTaskNode(nodeId, taskType, params, context) {
        await this._concurrencySemaphore.acquire();
        try {
            const job = await agendaInstance.now(taskType, params);
            return await this._waitForJobCompletion(job.attrs._id);
        } finally {
            this._concurrencySemaphore.release();
        }
    }
}
```

### 8.2 è½®è¯¢ä¼˜åŒ–

**é—®é¢˜**ï¼š`waitForJobCompletion` è½®è¯¢ MongoDB æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€ï¼Œé—´éš” 1 ç§’ï¼Œå¯èƒ½æµªè´¹èµ„æºã€‚

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
1. **çŸ­æœŸ**ï¼šä½¿ç”¨æŒ‡æ•°é€€é¿ï¼ˆåˆå§‹ 500msï¼Œæœ€å¤§ 5sï¼‰
2. **é•¿æœŸ**ï¼šæ”¹ç”¨ MongoDB Change Streams å®æ—¶ç›‘å¬ jobs é›†åˆå˜åŒ–

### 8.3 å‰ç«¯æ¸²æŸ“ä¼˜åŒ–

**é—®é¢˜**ï¼šReact Flow æ¸²æŸ“å¤§é‡èŠ‚ç‚¹æ—¶ï¼ˆ> 100ï¼‰å¯èƒ½å¡é¡¿ã€‚

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
1. ä½¿ç”¨ `memo()` åŒ…è£¹èŠ‚ç‚¹ç»„ä»¶ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
2. å¯ç”¨ React Flow çš„ `nodesDraggable={false}` åœ¨æ‰§è¡Œæ—¶ç¦ç”¨æ‹–æ‹½
3. ä½¿ç”¨è™šæ‹ŸåŒ–ï¼ˆ`react-virtualized`ï¼‰æ¸²æŸ“æ‰§è¡Œå†å²åˆ—è¡¨

---

## 9. æµ‹è¯•ç­–ç•¥

### 9.1 å•å…ƒæµ‹è¯•ï¼ˆVitestï¼‰

**è¦†ç›–ç›®æ ‡**ï¼š
- `DagParser`ï¼šæ‹“æ‰‘æ’åºæ­£ç¡®æ€§ã€ç¯æ£€æµ‹
- `ConditionEvaluator`ï¼šå„ç§æ¡ä»¶ç±»å‹
- `NodeExecutionStrategy`ï¼šé‡è¯•ã€è¶…æ—¶ã€è·³è¿‡
- `ExecutionContext`ï¼šèŠ‚ç‚¹è¾“å‡ºå­˜å‚¨ä¸è¯»å–

**æµ‹è¯•ç”¨ä¾‹ç¤ºä¾‹**ï¼š

```typescript
// applications/orchestrator/src/test/DagParser.test.ts
import { describe, it, expect } from 'vitest';
import { DagParser } from '../core/DagParser';

describe('DagParser', () => {
    it('åº”æ­£ç¡®è¯†åˆ«ç¯è·¯', () => {
        const definition = {
            nodes: [
                { id: 'A', type: 'task', position: { x: 0, y: 0 }, data: {} },
                { id: 'B', type: 'task', position: { x: 0, y: 0 }, data: {} },
                { id: 'C', type: 'task', position: { x: 0, y: 0 }, data: {} }
            ],
            edges: [
                { id: 'e1', source: 'A', target: 'B' },
                { id: 'e2', source: 'B', target: 'C' },
                { id: 'e3', source: 'C', target: 'A' }  // ç¯è·¯
            ]
        };
        
        const parser = new DagParser();
        expect(() => parser.parse(definition)).toThrow('å·¥ä½œæµå­˜åœ¨ç¯è·¯');
    });
    
    it('åº”æ­£ç¡®ç”Ÿæˆåˆ†å±‚æ‰§è¡Œè®¡åˆ’', () => {
        const definition = {
            nodes: [
                { id: 'start', type: 'start', position: { x: 0, y: 0 }, data: {} },
                { id: 'A', type: 'task', position: { x: 0, y: 0 }, data: {} },
                { id: 'B', type: 'task', position: { x: 0, y: 0 }, data: {} },
                { id: 'C', type: 'task', position: { x: 0, y: 0 }, data: {} }
            ],
            edges: [
                { id: 'e1', source: 'start', target: 'A' },
                { id: 'e2', source: 'A', target: 'B' },
                { id: 'e3', source: 'A', target: 'C' }  // B å’Œ C å¹¶è¡Œ
            ]
        };
        
        const parser = new DagParser();
        const plan = parser.parse(definition);
        
        expect(plan.layers).toEqual([
            ['start'],
            ['A'],
            ['B', 'C']  // ç¬¬ 3 å±‚ï¼šå¹¶è¡Œ
        ]);
    });
});
```

### 9.2 é›†æˆæµ‹è¯•

**æµ‹è¯•åœºæ™¯**ï¼š
- ç«¯åˆ°ç«¯å·¥ä½œæµæ‰§è¡Œï¼ˆä½¿ç”¨ `MockNodeExecutorAdapter`ï¼‰
- æ–­ç‚¹ç»­è·‘ï¼ˆæ¨¡æ‹Ÿå¤±è´¥åœºæ™¯ï¼‰
- tRPC subscription æ¨é€ï¼ˆä½¿ç”¨ WebSocket æµ‹è¯•å®¢æˆ·ç«¯ï¼‰

### 9.3 æµ‹è¯•è¦†ç›–ç‡

**ç›®æ ‡**ï¼š> 80%

å½“å‰è¦†ç›–æƒ…å†µï¼ˆæˆªè‡³ 2026-02-07ï¼‰ï¼š
- `DagParser`: 95%
- `WorkflowExecutor`: 88%
- `ExecutionContext`: 100%
- `ConditionEvaluator`: 90%
- `NodeExecutionStrategy`: 85%

---

## 10. æ‰©å±•æ€§è®¾è®¡

### 10.1 è‡ªå®šä¹‰èŠ‚ç‚¹ç±»å‹

**åœºæ™¯**ï¼šæœªæ¥éœ€è¦æ”¯æŒæ•°æ®åº“æŸ¥è¯¢èŠ‚ç‚¹ã€é‚®ä»¶å‘é€èŠ‚ç‚¹ç­‰ã€‚

**æ‰©å±•æ–¹å¼**ï¼š
1. åœ¨ `WorkflowNodeType` æšä¸¾ä¸­æ–°å¢ç±»å‹ï¼š`Database = "database"`
2. åœ¨ `NodeExecutorAdapter` æ¥å£ä¸­æ–°å¢æ–¹æ³•ï¼š`executeDatabaseNode()`
3. åœ¨ `WorkflowExecutor` ä¸­æ·»åŠ å¯¹åº”çš„ `case` åˆ†æ”¯
4. å‰ç«¯æ–°å¢èŠ‚ç‚¹ç»„ä»¶å’Œå±æ€§è¡¨å•

**ç¤ºä¾‹**ï¼š

```typescript
// common/contracts/workflow/index.ts
export enum WorkflowNodeType {
    // ...
    Database = "database"
}

// applications/orchestrator/src/adapters/NodeExecutorAdapter.ts
export interface NodeExecutorAdapter {
    // ...
    executeDatabaseNode(nodeId: string, query: string, context: ExecutionContext): Promise<NodeExecutionResult>;
}
```

### 10.2 æ’ä»¶åŒ–èŠ‚ç‚¹æ‰§è¡Œå™¨

**ç›®æ ‡**ï¼šå…è®¸ç¬¬ä¸‰æ–¹å¼€å‘è€…ç¼–å†™è‡ªå®šä¹‰èŠ‚ç‚¹æ‰§è¡Œå™¨ï¼ˆå¦‚è°ƒç”¨å¤–éƒ¨ APIï¼‰ã€‚

**è®¾è®¡**ï¼š
1. å®šä¹‰ `NodeExecutorPlugin` æ¥å£
2. åœ¨é…ç½®æ–‡ä»¶ä¸­æ³¨å†Œæ’ä»¶è·¯å¾„
3. Orchestrator å¯åŠ¨æ—¶åŠ¨æ€åŠ è½½æ’ä»¶

```typescript
export interface NodeExecutorPlugin {
    name: string;
    supportedNodeTypes: WorkflowNodeType[];
    execute(node: WorkflowNode, context: ExecutionContext): Promise<NodeExecutionResult>;
}
```

### 10.3 å­å·¥ä½œæµï¼ˆSub-Workflowï¼‰

**åœºæ™¯**ï¼šä¸€ä¸ªå·¥ä½œæµä¸­åµŒå¥—å¦ä¸€ä¸ªå·¥ä½œæµï¼ˆå¦‚æ‰¹é‡å¤„ç†ï¼‰ã€‚

**è®¾è®¡è¦ç‚¹**ï¼š
- æ–°å¢ `SubWorkflow` èŠ‚ç‚¹ç±»å‹
- èŠ‚ç‚¹é…ç½®ä¸­æŒ‡å®šå­å·¥ä½œæµ ID
- æ‰§è¡Œæ—¶é€’å½’è°ƒç”¨ `WorkflowExecutor.execute()`

---

## 11. å·²çŸ¥é—®é¢˜ä¸æœªæ¥è§„åˆ’

### 11.1 å·²çŸ¥é—®é¢˜

| é—®é¢˜ | å½±å“ | ä¼˜å…ˆçº§ | çŠ¶æ€ |
|------|------|--------|------|
| Agenda `maxConcurrency=1` é™åˆ¶å¹¶è¡Œ | ä¸­ | P1 | è®¡åˆ’ä¸­ |
| è½®è¯¢ MongoDB æ€§èƒ½å¼€é”€ | ä½ | P2 | è®¡åˆ’ä¸­ |
| è„šæœ¬èŠ‚ç‚¹ç¼ºå°‘æ²™ç®±éš”ç¦» | é«˜ï¼ˆå®‰å…¨é£é™©ï¼‰ | P0 | **å¾…ä¿®å¤** |
| æ— æ³•åŠ¨æ€ä¿®æ”¹è¿è¡Œä¸­çš„å·¥ä½œæµ | ä½ | P3 | å·²çŸ¥é™åˆ¶ |
| å‰ç«¯æ¸²æŸ“å¤§é‡èŠ‚ç‚¹æ—¶å¡é¡¿ | ä¸­ | P2 | å·²æœ‰ä¼˜åŒ–æ–¹æ¡ˆ |

### 11.2 æœªæ¥è§„åˆ’

#### Phase 3ï¼ˆè®¡åˆ’ä¸­ï¼‰ï¼šå‰ç«¯å¯è§†åŒ–å¢å¼º
- âœ… React Flow åŸºç¡€é›†æˆï¼ˆå·²å®Œæˆï¼‰
- âœ… è‡ªå®šä¹‰èŠ‚ç‚¹ç»„ä»¶ï¼ˆå·²å®Œæˆï¼‰
- âœ… æ‹–æ‹½æ·»åŠ èŠ‚ç‚¹ï¼ˆå·²å®Œæˆï¼‰
- â³ è‡ªåŠ¨å¸ƒå±€ï¼ˆDagre ç®—æ³•ï¼‰
- â³ èŠ‚ç‚¹æœç´¢ä¸è¿‡æ»¤
- â³ å·¥ä½œæµæ¨¡æ¿å¸‚åœº

#### Phase 4ï¼ˆå·²æš‚åœï¼‰ï¼šæ—¥å¿—ç³»ç»Ÿæ”¹é€ 
- Logger å¢åŠ  `executionId` æ ‡ç­¾
- åç«¯ Logs API æ”¯æŒæŒ‰ `executionId` è¿‡æ»¤
- å‰ç«¯å†…åµŒæ—¥å¿—é¢æ¿

**æš‚åœåŸå› **ï¼šå½“å‰æ—¥å¿—å¯é€šè¿‡ç³»ç»Ÿç›‘æ§é¡µé¢æŸ¥çœ‹ï¼Œä¼˜å…ˆçº§é™ä½ã€‚

#### Phase 5ï¼ˆé•¿æœŸï¼‰ï¼šåˆ†å¸ƒå¼æ‰§è¡Œ
- **é—®é¢˜**ï¼šå•æœº Orchestrator æ— æ³•æ°´å¹³æ‰©å±•
- **æ–¹æ¡ˆ**ï¼š
  - å¼•å…¥åˆ†å¸ƒå¼é”ï¼ˆRedisï¼‰
  - å¤šä¸ª Orchestrator å®ä¾‹ç«äº‰æ‰§è¡Œæƒ
  - ä½¿ç”¨ MongoDB Change Streams å®æ—¶åŒæ­¥çŠ¶æ€

#### Phase 6ï¼ˆæ¢ç´¢ä¸­ï¼‰ï¼šAI è¾…åŠ©ç¼–æ’
- **åŠŸèƒ½**ï¼šç”¨æˆ·è¾“å…¥è‡ªç„¶è¯­è¨€éœ€æ±‚ï¼ŒAI è‡ªåŠ¨ç”Ÿæˆå·¥ä½œæµ
- **æŠ€æœ¯æ ˆ**ï¼šLangChain + è‡ªå®šä¹‰ Prompt
- **ç¤ºä¾‹**ï¼š
  - è¾“å…¥ï¼š"æ¯å¤©æ—©ä¸Š 9 ç‚¹æ‹‰å–æ˜¨å¤©çš„èŠå¤©è®°å½•ï¼Œç”Ÿæˆæ‘˜è¦å¹¶å‘é€é‚®ä»¶"
  - è¾“å‡ºï¼šä¸€ä¸ªå®Œæ•´çš„ WorkflowDefinition JSON

---

## 12. å‚è€ƒèµ„æ–™

### 12.1 æ ¸å¿ƒä¾èµ–æ–‡æ¡£
- [React Flow Documentation](https://reactflow.dev/)
- [tRPC Documentation](https://trpc.io/)
- [Zustand Documentation](https://zustand-demo.pmnd.rs/)
- [Agenda Documentation](https://github.com/agenda/agenda)

### 12.2 ç®—æ³•ä¸è®¾è®¡æ¨¡å¼
- [Kahn æ‹“æ‰‘æ’åºç®—æ³•](https://en.wikipedia.org/wiki/Topological_sorting)
- [é€‚é…å™¨æ¨¡å¼ï¼ˆAdapter Patternï¼‰](https://refactoring.guru/design-patterns/adapter)
- [è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Pattern / EventEmitterï¼‰](https://nodejs.org/api/events.html)

### 12.3 å†…éƒ¨æ–‡æ¡£
- [Synthos ä¸»æ–‡æ¡£](../../README.md)
- [å·¥ä½œæµç¼–æ’ä½¿ç”¨æŒ‡å—](./å·¥ä½œæµç¼–æ’ä½¿ç”¨æŒ‡å—.md)ï¼ˆç”¨æˆ·æ‰‹å†Œï¼‰
- [Orchestrator æ¨¡å—æ–‡æ¡£](../../applications/orchestrator/README.md)
- [API æ–‡æ¡£ - Orchestrator RPC æ¥å£](./æ¥å£æ–‡æ¡£/APIæ–‡æ¡£.md#21-orchestrator-rpc-æ¥å£)

---

## 13. ä»»åŠ¡æ³¨å†Œæœºåˆ¶é‡æ„ï¼ˆè£…é¥°å™¨æ¨¡å¼ï¼‰

### 13.1 é‡æ„èƒŒæ™¯ä¸é—®é¢˜

åœ¨å·¥ä½œæµç³»ç»ŸåˆæœŸç‰ˆæœ¬ä¸­ï¼Œä»»åŠ¡å®šä¹‰é‡‡ç”¨**ç¡¬ç¼–ç æšä¸¾**æ–¹å¼ï¼Œè¿åå¼€é—­åŸåˆ™ï¼š

- **å¼€é—­åŸåˆ™è¿å**ï¼šæ–°å¢ä»»åŠ¡éœ€ä¿®æ”¹ 5+ æ–‡ä»¶ï¼ˆenumã€interfaceã€resolverã€å‰ç«¯ç»„ä»¶ï¼‰
- **ç¼ºä¹è¿è¡Œæ—¶æ ¡éªŒ**ï¼šå‚æ•°ç±»å‹ä»…ç¼–è¯‘æ—¶æ£€æŸ¥
- **å‰åç«¯ä¸åŒæ­¥**ï¼šå‰ç«¯ä»»åŠ¡åˆ—è¡¨æ‰‹åŠ¨ç»´æŠ¤
- **UI è¡¨å•ç¡¬ç¼–ç **ï¼šé’ˆå¯¹æ¯ä¸ªä»»åŠ¡æ‰‹å†™ switch-case
- **å…ƒæ•°æ®åˆ†æ•£**ï¼šæ˜¾ç¤ºåç§°ã€æè¿°ã€å‚æ•°é€»è¾‘åˆ†æ•£å¤šå¤„

### 13.2 é‡æ„æ–¹æ¡ˆï¼šè£…é¥°å™¨ + TaskRegistry

é‡‡ç”¨**è£…é¥°å™¨æ¨¡å¼**å®ç°ä»»åŠ¡è‡ªåŠ¨æ³¨å†Œå’Œå…ƒæ•°æ®ç®¡ç†ï¼Œæ ¸å¿ƒæ¶æ„ï¼š

```typescript
// 1. å®šä¹‰ Zod Schema
const ParamsSchema = z.object({
    groupIds: z.array(z.string()).min(1),
    startTimeStamp: z.number().int().positive()
});

// 2. ä½¿ç”¨ @Task è£…é¥°å™¨æ³¨å†Œ
@injectable()
@Task({
    displayName: "AI æ‘˜è¦ç”Ÿæˆ",
    paramsSchema: ParamsSchema,
    generateDefaultParams: async (context, config) => ({...}),
    uiConfig: {
        icon: "ğŸ¤–",
        formFields: [
            { name: "groupIds", type: "array", label: "ç¾¤ç»„åˆ—è¡¨", required: true },
            { name: "startTimeStamp", type: "timestamp", label: "å¼€å§‹æ—¶é—´" }
        ]
    }
})
export class AISummarizeTaskHandler {
    public static readonly TASK_NAME = "AISummarize";
}
```

**æ ¸å¿ƒç»„ä»¶**ï¼š

1. **TaskRegistry**ï¼šå•ä¾‹ï¼Œç®¡ç†æ‰€æœ‰ä»»åŠ¡å…ƒæ•°æ®ï¼ˆ`Map<string, TaskMetadata>`ï¼‰
2. **@Task è£…é¥°å™¨**ï¼šä»ç±»çš„é™æ€å±æ€§è·å– `TASK_NAME`ï¼Œè‡ªåŠ¨è°ƒç”¨ `registry.register()`
3. **Zod Schema**ï¼šè¿è¡Œæ—¶å‚æ•°æ ¡éªŒï¼Œå¯è½¬æ¢ä¸º JSON Schema ä¾›å‰ç«¯ä½¿ç”¨
4. **FormFieldConfig**ï¼šUI è¡¨å•å­—æ®µé…ç½®ï¼Œé©±åŠ¨å‰ç«¯åŠ¨æ€æ¸²æŸ“

### 13.3 å‰åç«¯é›†æˆ

**åç«¯**ï¼š
- TaskParamsResolver ä¼˜å…ˆä» TaskRegistry è·å–é»˜è®¤å‚æ•°ç”Ÿæˆå‡½æ•°å’Œæ ¡éªŒé€»è¾‘
- `/api/tasks/registry` æ¥å£æš´éœ²æ‰€æœ‰ä»»åŠ¡å…ƒæ•°æ®ï¼ˆå« JSON Schemaï¼‰
- ä¿ç•™ switch-case ä½œä¸ºå›é€€ï¼ˆå‘åå…¼å®¹ï¼‰

**å‰ç«¯**ï¼š
- ä» `/api/tasks/registry` åŠ¨æ€åŠ è½½ä»»åŠ¡åˆ—è¡¨
- `DynamicParamsForm` ç»„ä»¶æ ¹æ® `formFields` åŠ¨æ€æ¸²æŸ“è¡¨å•
- TaskPropertyForm ä¸å†ç¡¬ç¼–ç  TASK_TYPESï¼Œæ”¹ä¸ºä» API è·å–

### 13.4 é‡æ„æ•ˆæœå¯¹æ¯”

| ç»´åº¦ | é‡æ„å‰ | é‡æ„å |
|------|--------|--------|
| æ–°å¢ä»»åŠ¡éœ€ä¿®æ”¹æ–‡ä»¶æ•° | 5+ ä¸ª | 1 ä¸ªï¼ˆä»…ä»»åŠ¡å¤„ç†å™¨ï¼‰ |
| å‚æ•°æ ¡éªŒ | ä»…ç¼–è¯‘æ—¶ | ç¼–è¯‘æ—¶ + è¿è¡Œæ—¶ï¼ˆZodï¼‰ |
| å‰åç«¯åŒæ­¥ | æ‰‹åŠ¨åŒæ­¥ | è‡ªåŠ¨åŒæ­¥ï¼ˆAPI é©±åŠ¨ï¼‰ |
| UI è¡¨å• | ç¡¬ç¼–ç  switch-case | å…ƒæ•°æ®é©±åŠ¨ï¼ŒåŠ¨æ€æ¸²æŸ“ |
| å¼€é—­åŸåˆ™ | âŒ è¿å | âœ… ç¬¦åˆ |

### 13.5 æ·»åŠ æ–°ä»»åŠ¡æ­¥éª¤ï¼ˆé‡æ„åï¼‰

1. åˆ›å»ºä»»åŠ¡å¤„ç†å™¨ç±»ï¼Œå®šä¹‰ Zod Schema
2. æ·»åŠ  `@Task` è£…é¥°å™¨ï¼Œé…ç½® `displayName`ã€`uiConfig` ç­‰
3. å®ç° `register()` æ–¹æ³•æ³¨å†Œåˆ° Agenda
4. **å®Œæˆï¼**å‰ç«¯è‡ªåŠ¨è·å–å¹¶æ˜¾ç¤ºæ–°ä»»åŠ¡

---

**æ’°å†™æ—¥æœŸ**ï¼š2026-02-07  
**ä½œè€…**ï¼šSynthos å¼€å‘å›¢é˜Ÿ  
**ç‰ˆæƒ**ï¼šÂ© 2026 Synthos Project. All Rights Reserved.
